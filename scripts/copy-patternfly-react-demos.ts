#!/usr/bin/env tsx

/**
 * Copy React demo files from PatternFly React repository
 *
 * This script:
 * 1. Reads react-dependency-tree.json (generated by analyze-dependencies)
 * 2. Copies demo files to /patternfly-react/{component}/ with ORIGINAL names
 * 3. Generates /patternfly-react/demos.json manifest with name mappings for routing
 *
 * IMPORTANT: PatternFly has TWO types of components:
 * - Components: patternfly-react/packages/react-core/src/components/ (Button, Card, etc.)
 * - Layouts: patternfly-react/packages/react-core/src/layouts/ (Gallery, Grid, Flex, etc.)
 *
 * The manifest maps kebab-case URLs to actual file names:
 * {
 *   "Card": {
 *     "basic-cards": "CardBasic.tsx",
 *     "expandable-with-icon": "CardExpandableWithIcon.tsx"
 *   },
 *   "Gallery": {
 *     "basic": "GalleryBasic.tsx"
 *   }
 * }
 */

import { readFile, writeFile, mkdir, copyFile, readdir } from 'node:fs/promises';
import { existsSync, createReadStream, createWriteStream } from 'node:fs';
import { join, dirname, basename } from 'node:path';
import { fileURLToPath } from 'node:url';
import { createInterface } from 'node:readline';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');
const cacheDir = join(projectRoot, '.cache/patternfly-react');

interface DemoMapping {
  source: string;      // Original file name: "CardBasic.tsx"
  kebabCase: string;   // URL-friendly name: "basic-cards"
  exportName: string;  // React export name: "CardBasic"
}

interface ComponentDemos {
  sourceComponent: string;  // Original component name: "Card"
  demos: Record<string, string>;  // kebab-case ‚Üí source file mapping
}

interface Manifest {
  version: string;
  generatedAt: string;
  clonePath: string;
  components: Record<string, ComponentDemos>;
}

interface DependencyTreeComponent {
  name: string;
  source: string;
  type: 'component' | 'layout';
  files: {
    implementation: string;
    demos: string[];
  };
}

interface DependencyTree {
  generatedAt: string;
  sources: {
    patternflyReact: string;
  };
  components: DependencyTreeComponent[];
  statistics: {
    totalComponents: number;
    zeroDependencies: number;
    withDemoDependencies: number;
    averageDependencies: string;
  };
}

/**
 * Convert PascalCase to kebab-case for URL routing
 * Examples:
 * - CardBasic ‚Üí basic
 * - CardExpandableWithIcon ‚Üí expandable-with-icon
 * - CheckboxDisabled ‚Üí disabled
 * - CheckboxWithDescriptionBody ‚Üí with-description-body
 */
function toKebabCase(pascalCase: string, componentName: string): string {
  // Remove component prefix (e.g., "Card" from "CardBasic")
  let withoutPrefix = pascalCase;
  if (pascalCase.startsWith(componentName)) {
    withoutPrefix = pascalCase.slice(componentName.length);
  }

  // If nothing left after removing prefix, use the component name
  // Example: "Card" component with "Card.tsx" demo ‚Üí "cards"
  if (!withoutPrefix) {
    return `${componentName.toLowerCase()}s`;
  }

  // Convert to kebab-case
  const kebab = withoutPrefix
    .replace(/([A-Z])/g, '-$1')
    .toLowerCase()
    .replace(/^-/, '');

  return kebab;
}

/**
 * Get the installed version from package.json
 */
async function getPackageVersion(packageName: string): Promise<string> {
  try {
    const packageJsonPath = join(projectRoot, 'node_modules', packageName, 'package.json');
    const content = await readFile(packageJsonPath, 'utf-8');
    const pkg = JSON.parse(content);
    return pkg.version;
  } catch (error) {
    console.error(`Failed to get version for ${packageName}:`, error);
    throw error;
  }
}

/**
 * Extract import names from code to detect conflicts
 */
function extractImportedNames(code: string): Set<string> {
  const importedNames = new Set<string>();

  // Match import statements: import { A, B, C } from '...';
  const importPattern = /import\s+\{([^}]+)\}\s+from\s+['"][^'"]+['"]/g;
  let match;

  while ((match = importPattern.exec(code)) !== null) {
    const imports = match[1].split(',').map(name => name.trim());
    imports.forEach(importName => {
      // Handle "as" aliases: import { A as B }
      const parts = importName.split(/\s+as\s+/);
      const actualName = parts.length > 1 ? parts[1].trim() : parts[0].trim();
      importedNames.add(actualName);
    });
  }

  return importedNames;
}

/**
 * Detect if code contains bare JSX (no export, no const declaration)
 * Pattern: imports followed by JSX expression ending with semicolon
 *
 * Example bare JSX:
 *   import { Avatar } from '@patternfly/react-core';
 *   <Avatar src={img} alt="avatar" />;
 */
function isBareJsx(code: string): boolean {
  // Remove comments and whitespace
  const cleaned = code
    .replace(/\/\*[\s\S]*?\*\//g, '')
    .replace(/\/\/.*/g, '')
    .trim();

  // Split into lines
  const lines = cleaned.split('\n').filter(line => line.trim());

  // Check if code has:
  // 1. No 'export' keyword
  // 2. No 'const' declarations (except in imports)
  // 3. Ends with JSX (starts with < after imports)

  const hasExport = /^export\s+/.test(cleaned);
  const hasConstDeclaration = /^const\s+\w+\s*[=:]/.test(cleaned.replace(/^import.*/gm, ''));

  if (hasExport || hasConstDeclaration) {
    return false;
  }

  // Find first non-import line
  let firstNonImport = '';
  for (const line of lines) {
    if (!line.startsWith('import ')) {
      firstNonImport = line;
      break;
    }
  }

  // Check if it starts with JSX (< followed by uppercase letter or Fragment)
  return /^<[A-Z]/.test(firstNonImport) || /^<Fragment/.test(firstNonImport);
}

/**
 * Transform bare JSX into proper React component export
 *
 * Input:
 *   import { Avatar } from '@patternfly/react-core';
 *   <Avatar src={img} alt="avatar" />;
 *
 * Output:
 *   import { Avatar } from '@patternfly/react-core';
 *
 *   export const AvatarBasic: React.FunctionComponent = () => (
 *     <Avatar src={img} alt="avatar" />
 *   );
 */
function transformBareJsx(code: string, exportName: string): string {
  // Split into imports and JSX
  const lines = code.split('\n');
  const imports: string[] = [];
  const jsxLines: string[] = [];

  let inJsx = false;
  for (const line of lines) {
    if (line.trim().startsWith('import ')) {
      imports.push(line);
    } else if (line.trim()) {
      inJsx = true;
      jsxLines.push(line);
    } else if (inJsx) {
      jsxLines.push(line);
    }
  }

  // Get JSX content and remove trailing semicolon
  let jsx = jsxLines.join('\n').trim();
  if (jsx.endsWith(';')) {
    jsx = jsx.slice(0, -1);
  }

  // Indent JSX (2 spaces)
  const indentedJsx = jsx.split('\n').map(line =>
    line ? '  ' + line : line
  ).join('\n');

  // Build transformed code
  return `${imports.join('\n')}

export const ${exportName}: React.FunctionComponent = () => (
${indentedJsx}
);
`;
}

/**
 * Transform inline code to proper React component format
 * - Adds export statement
 * - Adds React.FunctionComponent type annotation
 * - Optionally renames component to match filename
 *
 * Returns: { code: transformed code, exportName: final export name }
 */
function transformInlineCode(
  code: string,
  exportName: string,
  shouldRename: boolean = true
): { code: string; exportName: string } {
  // Extract the original component name from the code
  // Match patterns like: const ComponentName = () => (
  const componentMatch = code.match(/const\s+(\w+)\s*[=:]/);
  const originalName = componentMatch ? componentMatch[1] : null;

  if (!originalName) {
    // If we couldn't find the pattern, add export to the beginning
    return { code: `export ${code}`, exportName };
  }

  let transformed = code;
  let finalExportName = exportName;

  if (shouldRename && originalName !== exportName) {
    // Rename to match filename AND check for conflicts
    const importedNames = extractImportedNames(code);

    if (importedNames.has(exportName)) {
      // Conflict detected - add "Example" suffix
      // PanelHeader ‚Üí PanelHeaderExample
      finalExportName = `${exportName}Example`;
    }

    // Replace the component declaration with export + type annotation + new name
    const declarationPattern = new RegExp(`const\\s+${originalName}\\s*=`, 'g');
    transformed = transformed.replace(
      declarationPattern,
      `export const ${finalExportName}: React.FunctionComponent =`
    );
  } else {
    // Keep original name (no rename, no conflict check needed)
    const declarationPattern = new RegExp(`const\\s+${originalName}\\s*=`, 'g');
    transformed = transformed.replace(
      declarationPattern,
      `export const ${originalName}: React.FunctionComponent =`
    );
    finalExportName = originalName;
  }

  return { code: transformed, exportName: finalExportName };
}

/**
 * Extract inline code blocks from markdown file
 * Writes extracted demos to targetDir (NOT .cache)
 */
async function extractInlineCodeFromMd(
  mdPath: string,
  componentName: string,
  targetDir: string
): Promise<DemoMapping[]> {
  const content = await readFile(mdPath, 'utf-8');
  const demos: DemoMapping[] = [];

  // Split by markdown headings (### )
  const sections = content.split(/^### /m).slice(1);

  for (const section of sections) {
    const lines = section.split('\n');
    const title = lines[0].trim();

    // Find inline code blocks (not file references)
    const codeMatch = section.match(/```(?:js|jsx|tsx)\n([\s\S]*?)```/);
    if (!codeMatch) continue;

    // Skip if it's a file reference
    const firstLine = codeMatch[1].trim().split('\n')[0];
    if (firstLine.includes('file=')) continue;

    const code = codeMatch[1].trim();

    // Generate filename from title (for URL routing)
    // "Basic" ‚Üí "PanelBasic"
    // "Header and footer" ‚Üí "PanelHeaderAndFooter"
    let fileName = title
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');

    if (!fileName.startsWith(componentName)) {
      fileName = componentName + fileName;
    }

    // Transform code but KEEP original const name (don't rename)
    // This preserves the markdown author's naming choices (e.g., "HeaderPanel" instead of "PanelHeader")
    // which avoids import conflicts
    const { code: transformedCode, exportName: finalExportName } = transformInlineCode(code, fileName, false);

    // Use filename (without "Example" suffix) for file creation
    const finalFileName = fileName + '.tsx';

    // Write to patternfly-react/ (NOT .cache)
    await mkdir(targetDir, { recursive: true });
    const filePath = join(targetDir, finalFileName);
    await writeFile(filePath, transformedCode + '\n', 'utf-8');

    // Generate URL from filename (clean, no "Example")
    const kebabCase = toKebabCase(fileName, componentName);
    demos.push({
      source: finalFileName,
      kebabCase,
      exportName: finalExportName
    });
  }

  console.log(`   ‚úì Extracted ${demos.length} inline demo(s) from ${basename(mdPath)} for ${componentName}`);
  return demos;
}

/**
 * Copy demo files for a component
 */
async function copyComponentDemos(
  component: DependencyTreeComponent,
  targetDir: string
): Promise<DemoMapping[]> {
  const { name: componentName, files } = component;
  const { demos } = files;

  // Check if component has .tsx demo files in cache
  const implementationPath = join(projectRoot, files.implementation);
  const examplesDir = join(dirname(implementationPath), 'examples');

  if (!existsSync(examplesDir)) {
    console.log(`   ‚ö† No examples directory for ${componentName}`);
    return [];
  }

  const exampleFiles = await readdir(examplesDir);
  const hasTsxFiles = exampleFiles.some(f => f.endsWith('.tsx') && !f.includes('.test.'));

  if (hasTsxFiles) {
    // CASE 1: Component has .tsx files - copy them (existing logic)
    if (demos.length === 0) {
      console.log(`   ‚ö† No demos for ${componentName}`);
      return [];
    }

    // Create target directory
    await mkdir(targetDir, { recursive: true });

    const mappings: DemoMapping[] = [];
    let copiedCount = 0;
    let layoutCount = 0;

    for (const demoPath of demos) {
      // Handle both .tsx files and .md files (layouts)
      const fileName = basename(demoPath);
      const isMarkdown = fileName.endsWith('.md');

      if (isMarkdown) {
        // Copy .md files (layout component documentation)
        const sourcePath = demoPath;
        const targetPath = join(targetDir, fileName);

        if (existsSync(sourcePath)) {
          await copyFile(sourcePath, targetPath);
          layoutCount++;
        }

        // Also copy associated .css files if present
        const cssFile = demoPath.replace('.md', '.css');
        if (existsSync(cssFile)) {
          await copyFile(cssFile, join(targetDir, basename(cssFile)));
        }
      } else if (fileName.endsWith('.tsx')) {
        // Copy .tsx files with transformation if needed
        const sourcePath = demoPath;
        const targetPath = join(targetDir, fileName);

        if (existsSync(sourcePath)) {
          // Read the file content
          const content = await readFile(sourcePath, 'utf-8');

          // Extract export name (assume it matches filename without extension)
          const exportName = fileName.replace('.tsx', '');

          // Check if it's bare JSX and transform if needed
          let transformedContent = content;
          if (isBareJsx(content)) {
            transformedContent = transformBareJsx(content, exportName);
            console.log(`      ‚Ü™ Transformed bare JSX in ${fileName}`);
          }

          // Write transformed content
          await writeFile(targetPath, transformedContent, 'utf-8');

          const kebabCase = toKebabCase(exportName, componentName);

          mappings.push({
            source: fileName,
            kebabCase,
            exportName,
          });

          copiedCount++;
        }
      }
    }

    if (layoutCount > 0) {
      console.log(`   ‚úì Copied ${layoutCount} .md file(s) for ${componentName} (layout) - needs extraction`);
    }

    if (copiedCount > 0) {
      console.log(`   ‚úì Copied ${copiedCount} demo(s) for ${componentName} (component)`);
    }

    return mappings;
  } else {
    // CASE 2: Component has only .md files - extract inline code
    const mdFile = exampleFiles.find(f => f.endsWith('.md'));
    if (mdFile) {
      return extractInlineCodeFromMd(
        join(examplesDir, mdFile),
        componentName,
        targetDir
      );
    }

    console.log(`   ‚ö† No .tsx or .md files for ${componentName}`);
    return [];
  }
}


/**
 * Stream-parse JSON components array from dependency tree
 * This avoids loading the entire file into memory
 */
async function* streamComponents(treeFile: string): AsyncGenerator<DependencyTreeComponent> {
  const fileStream = createReadStream(treeFile, { encoding: 'utf-8' });
  const rl = createInterface({ input: fileStream, crlfDelay: Infinity });

  let inComponentsArray = false;
  let currentComponent = '';
  let braceDepth = 0;
  let baseIndent = 0;

  for await (const line of rl) {
    const trimmed = line.trim();

    // Detect components array start
    if (trimmed === '"components": [') {
      inComponentsArray = true;
      continue;
    }

    if (!inComponentsArray) continue;

    // Detect components array end (only at top level, braceDepth must be 0)
    if (braceDepth === 0 && (trimmed === '],' || trimmed === ']')) {
      break;
    }

    // Track brace depth to know when we have a complete component object
    for (const char of line) {
      if (char === '{') {
        braceDepth++;
        // Record base indent level on first brace of a component
        if (braceDepth === 1 && baseIndent === 0) {
          baseIndent = line.indexOf('{');
        }
      }
      if (char === '}') {
        braceDepth--;
      }
    }

    // Accumulate component JSON
    if (braceDepth > 0 || trimmed.endsWith('}') || trimmed.endsWith('},')) {
      currentComponent += line + '\n';
    }

    // When braces balance and we have content, we have a complete component
    if (braceDepth === 0 && currentComponent.trim()) {
      // Remove leading/trailing whitespace and trailing comma
      const componentJson = currentComponent.trim().replace(/,\s*$/, '');

      try {
        const component: DependencyTreeComponent = JSON.parse(componentJson);
        yield component;
      } catch (e) {
        console.warn('‚ö†Ô∏è  Skipped malformed component entry:', (e as Error).message);
      }

      currentComponent = '';
      baseIndent = 0;
    }
  }
}

/**
 * Main function with streaming JSON processing
 */
async function main() {
  console.log('üöÄ Copying React demos from PatternFly React cache...\n');

  try {
    // Verify cache exists
    if (!existsSync(cacheDir)) {
      console.error('‚ùå Cache directory not found. Run: npm run patternfly-cache');
      process.exit(1);
    }

    // Check dependency tree exists
    const treeFile = join(projectRoot, 'react-dependency-tree.json');
    if (!existsSync(treeFile)) {
      console.error('‚ùå react-dependency-tree.json not found. Run: npm run analyze-dependencies');
      process.exit(1);
    }

    console.log(`üìå Using PatternFly React from cache\n`);

    // Get version from package.json early
    const version = await getPackageVersion('@patternfly/react-core');

    // Stream manifest writing
    const manifestPath = join(projectRoot, 'patternfly-react/demos.json');
    const manifestStream = createWriteStream(manifestPath, { encoding: 'utf-8' });

    // Write manifest opening
    manifestStream.write('{\n');
    manifestStream.write(`  "version": "${version}",\n`);
    manifestStream.write(`  "generatedAt": "${new Date().toISOString()}",\n`);
    manifestStream.write(`  "clonePath": "${cacheDir}",\n`);
    manifestStream.write('  "components": {\n');

    // Copy demos for each component (streaming)
    console.log('üìã Copying component demo files...');
    let totalDemos = 0;
    let componentsWithDemos = 0;
    let processedComponents = 0;
    let isFirstManifestEntry = true;

    for await (const component of streamComponents(treeFile)) {
      processedComponents++;

      // Skip layout components - they have a different demo structure
      if (component.type !== 'component') {
        continue;
      }

      const targetDir = join(projectRoot, 'patternfly-react', component.name);
      const mappings = await copyComponentDemos(component, targetDir);

      if (mappings.length > 0) {
        // Write to manifest stream immediately
        if (!isFirstManifestEntry) {
          manifestStream.write(',\n');
        }
        isFirstManifestEntry = false;

        const demos: Record<string, string> = {};
        for (const mapping of mappings) {
          demos[mapping.kebabCase] = mapping.source;
        }

        const componentEntry = {
          sourceComponent: component.name,
          demos,
        };

        const entryJson = JSON.stringify(componentEntry, null, 2);
        const indented = entryJson.split('\n').map((line, i) =>
          i === 0 ? `"${component.name}": ${line}` : line
        ).join('\n');

        manifestStream.write(indented);

        componentsWithDemos++;
        totalDemos += mappings.length;
      }

      // Memory hint: allow GC after processing each component
      if (global.gc && processedComponents % 10 === 0) {
        global.gc();
      }
    }

    // Write manifest closing
    manifestStream.write('\n  }\n');
    manifestStream.write('}\n');
    manifestStream.end();

    await new Promise((resolve, reject) => {
      manifestStream.on('finish', resolve);
      manifestStream.on('error', reject);
    });

    console.log();
    console.log(`\n‚úì Generated manifest: patternfly-react/demos.json`);

    // Summary
    console.log('\n‚úÖ Done!');
    console.log(`   Components processed: ${processedComponents}`);
    console.log(`   Components with demos: ${componentsWithDemos}`);
    console.log(`   Total component demos copied: ${totalDemos}`);
    console.log(`   Location: ${join(projectRoot, 'patternfly-react')}`);

  } catch (error) {
    console.error('\n‚ùå Error:', error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { main as copyReactDemos };
